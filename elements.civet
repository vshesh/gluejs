XRegExp from 'XRegExp'
getopts from "getopts" 
import * as R from "ramda";
import {format} from './util';

// I will make mistakes when transcribing from python... 
type str = string
r := String.raw 
regex := XRegExp 

// ramda has a function with proper ts types for this
// Object.defineProperty(String.prototype, 'reverse', {
//   value: function () {return this.split('').reverse().join('')}
// })

// akin to python str.translate
function translate(from: string, to: string)
    translate := (c: string) => { 
      i := from.indexOf(c)
      i >= 0 ? to[i] : i 
    }
    (s:string) => s.split('').map(translate).join('')

function num_groups(regex:RegExp): number
  return ((new RegExp(regex.toString() + '|')).exec('') || []).length - 1;

function escape(string: string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}

/** capitalized so it looks like a class. this is an enum with string value instead of int */ 
export Patterns := {
  escape : r`(?<!\\)(?:\\\\)*{0}`,
  single_group : r`(?<!\\)(?:\\\\)*{0}(.*?(?<!\\)(?:\\\\)*){1}`,
  link : r`(?<!\\)(?:\\\\)*{0}\[((?:(?:[^\[])|(?:\[.*?\]))*?(?<!\\)(?:\\\\)*)\]\(((?:\([^\)]*\)|[^)\n])*)\)`,
  double_group : r`(?<!\\)(?:\\\\)*\{0}(.*?(?<!\\)(?:\\\\)*){1}(.*?(?<!\\)(?:\\\\)*){2}`,
  // matches structures like <ident.class.class2:text> useful for one line html tag formats.
  tag_simple : r`(?<!\\)(?:\\\\)*<([a-zA-Z][a-zA-Z0-9_-]*)((?:\.[a-zA-Z][a-zA-Z0-9_-]*)*):\s*([^>]+)>`,
  tag_attributes : r`(?<!\\)(?:\\\\)*<([a-zA-Z][a-zA-Z0-9_-]*)((?:\.[a-zA-Z][a-zA-Z0-9_-]*)*)(?:\s+([a-zA-Z]+)=("[^"]+"))+:\s*([^>]+)>`,
}

/**
FRAME: element is intended to contain/frame the inside
       text, which means that subscriptions should be inherited from the parent.

POST: text in the block should be parsed AFTER this block is
      parsed. This is the default, and is suitable for most situations.

SUB: the inside of the text is parsed for child nodes (inline and
     block) first, and the corresponding sections are replaced with [|*|] style
     tags that are meant to be left UNTOUCHED. After this block is parsed,
     then the tags are replaced with the appropriate parsed sections. This could
     have also been called 'PRE', since it pre-parses the contents before
     calling the block's parsing function.

NONE: terminal element. The parser's output is taken verbatim, with out any
      further processing of its insides.
*/
export enum Nesting { FRAME, POST, SUB, NONE }

export enum Display { BLOCK, INLINE }

export enum AssetType {JS, CSS} 

const makename = (name: string) => 
  name.replace(/([a-z])([A-Z])/g, (_, l, u) => `${l}-${u.toString().toLowerCase()}`).toLowerCase() 


// const makename = _.kebabCase 

type HTMLAttrs    = {[s:string]: string | number | boolean | {[_:string]: string | number | boolean}}
type HTMLChildren<S> = string | number | boolean | S
type Tag = [string, ...HTMLChildren<Tag>[]] | [string, HTMLAttrs, ...HTMLChildren<Tag>[]]
type HTML = {
  tag: string,
  attrs?: HTMLAttrs,
  children: HTMLChildren<HTML>[]
}
type SubElement = Element | 'all' | 'inherit';
// i can't remember why i thought i needed (e) => boolean (predicate) as an option.
export type BlockOptions = {[ss:string]: number | string | boolean | ((e:unknown) => boolean)}
export type Parser = (text: string, o?: BlockOptions, ...args:string[]) => Tag2
export type InlineParser = (groups: string[], o?: BlockOptions) => Tag2

###
Basic Element class, more or less a named tuple with some convenience functions. 
###
export class Element 
  readonly name: string; 
  assets: string[];
  @(parse: (...args: any[]) => Tag, public nest: Nesting, public subElements: SubElement[]) {
    @name = makename(parse.name)
    @assets = []
  }

  sub<T extends Element>(clazz: abstract new (...args: any) => T) { 
    return this.subElements.filter((x): x is T => x instanceof clazz) 
  } 



export class Block < Element 
  opts: BlockOptions
  @(public parse: Parser, 
    nest: Nesting=Nesting.POST, 
    sub: SubElement[]=['all'], 
    opts: BlockOptions={}) {
    super(parse, nest, sub)
    @opts = opts
  }

export class Inline < Element
  regex: RegExp
  display: Display
  escape: string
  @(pattern: string | RegExp,
    // note, Inline parsers do not require options, so (s: string) => HTML is fine
    public parse: InlineParser, 
    nest: Nesting = Nesting.FRAME, 
    sub: SubElement[] = ['all'], 
    escape: str = '', 
    display: Display = Display.INLINE)
    super(parse, nest, sub ?? ['all'])
    @regex = pattern instanceof RegExp ? pattern : regex(pattern)
    @escape = escape 
    @display = display 

  validate() 
    pattern := @regex.toString().slice(1,-1)
    if @display is Display.BLOCK and !(pattern.startsWith('^') and pattern.endsWith('$'))
    then false 
    else true 

// two more element sublcass might be BlockComponent and InlineComponent 
// in that case attributes would also be parsed for example.
// this would be a good use case for julia multiple dispatch 
// parse(

###
Unlike python, javascript does not have keyword args. 
That makes the design of the libraries I'm using a little cumbersome to use. 

I either have to do 
```js
new Block(Nesting.POST, ['all'], {}, function (text, opts) {

})
```
which is more js like, but then I cannot have good defaults (as you 
have to specify all positional arguments before the function), or I have to do 
```
new Block(function (text, opts) {
  
}, Nesting.POST, ['all'], {})
```

In python I could be more clever and seperate the two kinds of data with 
function syntax. This looks much cleaner.
```python
@block(Nesting.POST, ['all'], "lskdjfc:")
def BlockName(text: str, opts: Mapping[str, str]):
  ...
```


The closest I could get in JS is to wrap a class: 
```ts
@block(Nesting.POST, ['all'], {l: 1, s: true, ...})
class BlockName {
  parse(text: str, opts: BlockOptions): Tag {
    // do something
  }
}
```
Ok I guess there is one more option
```
block()(function (text, opts) {

})
```
While this is not very js like it does have the benefit of letting you overload 
things where you want to overload them.
I'm probably overthinking this as no one is going to use this library but me anyway

The correct thing in JS would be 

new Block({
  name: 
})

But this is incorrect! `BlockName` should be an *instance* of `Block`, 
not a subclass of block. :( I could hack an instance of Block in 
place of that class. That's about the best I can hope for, I think. 

The main reason this works in python is that a `Callable` class is 
conflatable with a method (it's just a function with some parameters). 
In Javascript it isn't as easy to make this change. 

If I chose to implement Blocks and Inlines as functions with extra 
parameters (in other words have element extend function) this is called a 
Hybrid Type and is deprecated in Typescript. It's also cumbersome to set up 
because it requires writing and interface, function, and class to get typechecked, 
at which point the class syntax above starts to look preferable. 
It would also require everyone consuming the library in Typescript to also 
do the same set up. 

Probably the best solution is to rethink and write block as a series of 
behaviors... so: 

abstract class Block < Element 
  abstract parse(text: str, opts: BlockOptions={}): Tag
  abstract get nest(): Nesting
  abstract get sub(): SubElement
  abstract get opts(): BlockOptions

But this is stupid. The other option is to forgo the class bs and 
"just use maps" clojure style. This may be the way to go. 

In that case 
const SomeBlock = terminal_block()(function (...) {

})

Still not the best syntax and makes it hard to check whether something is a Block or not. 
###




### 
Convenience function for making blocks, defines defaults and doesn't require `new Block(...)`
which leads to odd syntax in some places where I'm trying to be functional. ###
export function block(parser: Parser, nest?:Nesting, sub?: SubElement[], opts?:BlockOptions): Block
export function block(parser: undefined, nest?: Nesting, sub?: SubElement[], opts?: BlockOptions): (p:Parser) => Block
export function block(nest?:Nesting, sub?: SubElement[], opts?:BlockOptions): (p:Parser) => Block
export function block(obj: {nest?:Nesting, sub?:SubElement[], opts?:BlockOptions, parser:Parser}): Block
export function block(obj: {nest?:Nesting, sub?:SubElement[], opts?:BlockOptions}): (p:Parser) => Block
export function block(one?:any, two?:any, three?:any, four?:BlockOptions): Block | ((p:Parser) => Block)
  if typeof(one) === 'object' // R.type(one) === 'Object'
    return block(one.parser, one.nest, one.sub, one.opts)
  else 
    if one == undefined 
      return (p: Parser) => block(p, two, three, four)
    if typeof(one) !== 'function' 
      return (p: Parser) => block(p, one, two, three)
    return new Block(one, two, three, four)

### 
Convenience function for making inlines, defines defaults and doesn't require `new Inline(...)`
which leads to odd syntax and unnecessary verbosity in some places where I'm trying to be functional. ###
export function inline(regex: RegExp | string, parser: InlineParser, nest?:Nesting, escape?:string, sub?: SubElement[], display?:Display): Inline
export function inline(regex: RegExp, nest?: Nesting, escape?: string, sub?: SubElement[], display?: Display): (p:InlineParser) => Inline
export function inline(nest?:Nesting, escape?:string, sub?: SubElement[], display?:Display): (r: RegExp | string, p:InlineParser) => Inline
export function inline(obj: {nest?:Nesting, escape?: string, sub?:SubElement[], display?:Display, regex: RegExp | string, parser:InlineParser}): Inline
export function inline(obj: {nest?:Nesting, escape?: string, sub?:SubElement[], display?:Display, regex: RegExp | string}): (p:InlineParser) => Inline
export function inline(obj: {nest?:Nesting, escape?: string, sub?:SubElement[], display?:Display}): (r: RegExp | string, p:InlineParser) => Inline
// these two are purely to make the object version work generically, not intended to be used by others.
export function inline(regex: undefined, parser: undefined, nest?: Nesting, escape?: string, sub?: SubElement[], display?: Display): (r: RegExp | string, p:InlineParser) => Inline
export function inline(regex: RegExp, parser: undefined, nest?: Nesting, escape?: string, sub?: SubElement[], display?: Display): (p:InlineParser) => Inline
export function inline(a?: any, b?:any, c?:any, d?:any, e?:any, f?:Display): Inline | ((p: InlineParser) => Inline) | ((r: RegExp | string, p:InlineParser) => Inline)
  if R.type(a) is 'Object' then return inline(a.regex, a.parser, a.nest, a.escape, a.sub, a.display)
  if a instanceof RegExp and R.type(b) is 'Function' then return new Inline(a, b, c, d, e, f)
  if a is undefined then return (regex: RegExp | string, p: InlineParser) => inline(regex, p)
  return (regex: RegExp | string, p: InlineParser) => inline(regex, p, a, b, c, d)

### 
------------------------------ BLOCK HELPERS -------------------------------------------------
###

### 
A block that does it's own processing and does not have any sub-elements
Common example would be integrations with other plain text syntaxes, like KaTeX. ###
export function terminal_block(opts: BlockOptions={})
  (p: Parser) => block(p, Nesting.NONE, [], opts)

/**
  Quick and dirty unique ID. I don't need super cryptographic security, just something
  that isn't going to be the same every time it's called to beat caching algorithms 
  in most frontend rendering libraries. 
*/
unique_id := => return Date.now().toString(36) + Math.random().toString(36).substring(2);

export function standalone_integration(outer_elem='div', inner_elem='div')

  function standalone_integration_wrapper(f: (text: string, docid: string, elem: string, opts?: BlockOptions) => Tag2)
    docid := makename(f.name) + '-' + unique_id()
    elem := `document.getElementById(${docid})`

    function standalone_block(text:str, opts?: BlockOptions): Tag2
      [[outer_elem + '.' + makename(f.name), {}],
        [[inner_elem + `#${docid}`, {key: docid+'-container'}]],
        [['script', {key: docid}], f(text, docid, elem, opts)]]

    terminal_block()(standalone_block)


### 
------------------------------ INLINE HELPERS -------------------------------------------------
###

export function inline_one(start: string, end: string, nest=Nesting.FRAME, sub=undefined, display=Display.INLINE) 
  patt := new RegExp(Patterns.single_group.replace('{0}', start).replace('{1}', end))
  (p: InlineParser) => inline(patt, p, nest, start.slice(0,1) + end.slice(0,1), sub, display)

type Attrs = {[s: string]: string}
export function SingleGroupInline(name: string, start: string, end: string, tag: string, attr: Attrs= {})
  obj := {
    [name](body: string[]): Tag2 {
      return [[tag, attr], ...body]
    }
  }
  inline_one(escape(start), escape(end))(obj[name])

export function IdenticalInline(name: string, s: string, tag: string, attr: Attrs={})
  SingleGroupInline(name, s, s, tag, attr)

export function MirrorInline(name: string, start: string, tag: string, attr: Attrs={}) 
  SingleGroupInline(name, start, R.reverse(start) |> translate('()[]{}<>', ')(][}{><'), tag, attr)

export function link(designation: string, nest:Nesting=Nesting.POST, sub?:SubElement[])
  pattern := regex(Patterns.link.replace('{0}', designation))
  (p:InlineParser) => inline(pattern, p, nest, "()[]"+(designation[0] ?? ''), sub)

export function inline_two(start: string, mid: string, end: string, nest:Nesting=Nesting.POST, sub:SubElement[]=['all'])
  pattern := regex( format(Patterns.double_group, start, mid, end))
  inline(pattern, nest, '', sub)


### ==========================================================================================
                                       REGISTRY FUNCTIONS 
============================================================================================= ###

export class Registry extends Map<string, Element>
  @(...args: any[])
    super(...args)
  
  add(...args:(Element | [string, Element])[])
    for a of args 
      if a <? Element 
        this.set(a.name, a)
      else
        this.set(...a)
    this

  resolve(e: Element | string): Element 
    if e <? Element 
      e 
    else // e <? String 
      v .= this.get(e)
      if v is undefined then throw Error(`Element ${e} not found in registry ${this}`) 
      v
  
  inlines() 
    Array.from(@values()).filter( (x): x is Inline => x <? Inline)

  blocks() 
    Array.from(@values()).filter((x): x is Block => x <? Block)

  assets() 
    Array.from(@values()).map( (x) => x.assets.join('\n')).join('\n\n\n')

  validate() 
    true
    
  inline_subscriptions(names: (string | SubElement)[], parent?: Element): Inline[]
    if R.includes('all', names) then return @inlines() 
    l : Inline[] .= []
    if parent and 'inherit' in names 
      if R.includes('all', parent.subElements) then return @inlines() 
      i .= parent.sub(Inline)
      l.concat(parent.sub(Inline))
    return []

// this is just Object.assign(...), do I need a special function for this? 
export function union(r1: Registry, r2: Registry) 
  Object.assign({}, r1, r2)

export function diff(r1: Registry, r2: Registry) 
  o: Registry .= new Registry()
  for k in r1
    if k not in r2 and r1.get(k) !== undefined then o.set(k, r1.get(k) as Block | Inline)
  o 

### ===========================================================================================
                                         PARSING FUNCTIONS 
=========================================================================================== ###

function* splicehtmlmap<B,L>(f: (t:string) => (L | ArrayBranch<B, L>)[], html: ArrayBranch<B, L>): Generator<(L | ArrayBranch<B, L>), unknown, unknown>
  yield R.head(html)
  for e of R.tail(html) 
    if e <? Array
      yield Array.from(splicehtmlmap(f, e))
    else if typeof e === 'string'
      yield f(e)
    else 
      yield e 

  
// this whole parsing situation needs to be made more functional 
// i don't like how many lines of code there are that I can't test in isolation.
// this is what happens when you write something in a couple weekends.

export function parseinline(registry: Registry, _element: Element | str, text: str, parent?:Element): (string | Tag2)[]
  console.log('parseinline', _element, text)
  if text is '' then return []  

  element : Element := registry.resolve(_element) 
  subinline: Inline[] := registry.inline_subscriptions(element.sub(Inline), parent)
  if subinline.length === 0 then return [text] 

  inlines : [RegExp, [InlineParser, Inline]][] := subinline.map( (x) => [x.regex, [x.parse, x]])
  escapes .= subinline
    .map((x) => x.escape.split(''))
    .reduce(R.union)
    .join('')
    .replace('[', '\\[').replace(']', '\\]')
  
  unescape := escapes.length > 0 ? (t: string) => t.replace(regex(`\\\\([${regex.escape(escapes)}])`), `$1`) : R.identity

  patt: RegExp := inlines
    .map((x) => `(?:${if typeof(x[0]) === 'string' then x[0] else x[0].source})`)
    .join('|') |>  (x) => regex(x, 'sg')

  groupcursors: number[] := subinline |> 
    R.map((x: Inline) => num_groups(x.regex)) |> 
    R.mapAccum((a:number,b:number) => [a+b, a+b], 0) |>
    (x) => x[1] |>
    R.prepend(0)

  // todo(vishesh)
  // ^ all of this is just setup that is specific to the element being parsed. 
  // one could imagine in the future that the registry just memoizes this computation 
  // and returns the patterns and cursors for each element. Most of them will be `all`,
  // or inherit from `all`, saving a lot of compiling.
  // also this function will look cleaner.
  
  matches := text.matchAll(patt)

  let ind = 0
  let l: (string | Tag2)[] = []
  for match of matches 
    // console.log(
    //   `Found ${match[0]} start=${match.index} end=${
    //     match.index + match[0].length
    //   }.`,
    // )
    start := match.index
    end := match.index + match[0].length
    // contains capture groups from all matches, even ones that didn't match. 
    allgroups := Array.from<string>(match).slice(1)
    // first index in all groups that has a value 
    groupind := R.findIndex((x) => x is not undefined)(allgroups)
    // convert to index of the matched element's pattern
    pattind := R.findIndex((x) => x >= groupind, groupcursors)
    // console.log(allgroups, groupind, pattind)
    [parser, elem] := inlines[pattind][1]
    // todo ^ this kind of stuff is unnecessary. can just do inlines[pattind]{parser, elem}

    // groups of the matching pattern
    groups := R.slice(groupcursors[pattind], groupcursors[pattind+1] ?? Infinity, allgroups)

    // all text before this match
    l.push(R.slice(ind, start, text))
    // set ind to end of this string, for the next match
    ind = end

    switch elem.nest 
      when Nesting.FRAME 
        l.push(Array.from(splicehtmlmap((t) => parseinline(registry, element, t, parent), parser(groups))) as string | Tag2)
      when Nesting.NONE 
        l.push(Array.from(parser(groups)))
      when Nesting.POST 
        // todo(vishesh) i need to rethink this. the python transliteration 
        // is putting inlines in place of blocks but then calls subinline on them
        // and i'm not sure how that's resolving. 
        // the clean implementation would be to parse a block of text for a list of 
        // acceptable inline elements instead of just one. 
        // then here we would use the registry to resolve what those acceptable styles are
        // moving the management of dependencies out of this function.
        l.push(Array.from(splicehtmlmap( (t) => parseinline(
          registry, 
          if R.includes('inherit', elem.sub(Inline)) then element else elem,
          t,
          if R.includes('inherit', elem.sub(Inline)) then parent else element
        ), parser(groups) )))
      when Nesting.SUB 
        // this is meaningless for inline elements. 
        // they parse capture groups, not text directly. 
        l.push([['', {}], `why does your inline element ${elem} have nesting = Nesting.SUB?`])

  if ind < text.length 
    l.push(text.slice(ind)) 

  l





// ========================================================================================
// ========================================================================================
// ▀█▄   ▀█▀                        ▀██▀▀█▄                                         
//  █▀█   █    ▄▄▄▄  ▄▄▄ ▄▄▄ ▄▄▄     ██   ██  ▄▄▄▄   ▄▄▄ ▄▄   ▄▄▄▄    ▄▄▄▄  ▄▄▄ ▄▄  
//  █ ▀█▄ █  ▄█▄▄▄██  ██  ██  █      ██▄▄▄█▀ ▀▀ ▄██   ██▀ ▀▀ ██▄ ▀  ▄█▄▄▄██  ██▀ ▀▀ 
//  █   ███  ██        ███ ███       ██      ▄█▀ ██   ██     ▄ ▀█▄▄ ██       ██     
// ▄█▄   ▀█   ▀█▄▄▄▀    █   █       ▄██▄     ▀█▄▄▀█▀ ▄██▄    █▀▄▄█▀  ▀█▄▄▄▀ ▄██▄    
// ========================================================================================
// ========================================================================================

function realQ<X>(x:X | null | undefined): x is X 
  x is not null and x is not undefined 

/**
TODO(vishesh): figure out how to extend the parser to work with 
any general shape of tree. 
That doesn't seem to be easy to do in js, or requires the use of 
more functional architecture than desired, 
such as here:  https://github.com/brucou/functional-rose-tree

right now i've implemented the functions for arraytrees which are 
one concrete implementation of a tree, you could implement it for 
any other type of tree you like. 
*/
type ArrayBranch<B, L> = [B, ...(L | ArrayBranch<B, L>)[]]
type ArrayTree<B, L> = L | ArrayBranch<B, L>
type ArrayForest<B, L> = ArrayTree<B, L>[]
// type ArrayTree<B, L> = L | [B, ...ArrayTree<B, L>[]] 
// ^ can't distinguish branch from leaf in this implementation so it doesn't typecheck properly

function isLeaf<B, L>(n: ArrayTree<B, L>): n is L  {!(n <? Array)}
function value<B, L>(n: ArrayBranch<B,L>): B { n[0] }
function construct<B, L>(b: B, branches: (L | ArrayBranch<B, L>)[]): ArrayBranch<B, L> { [b, ...branches] }
function attach<B, L>(n: ArrayBranch<B, L>, branches: (L | ArrayBranch<B, L>)[]): ArrayBranch<B, L> { [...n, ...branches]}
function branch<B, L>(n: L | ArrayBranch<B, L>): (L | ArrayBranch<B, L>)[] {
    if isLeaf(n) then return []
    const [_, ...rest] = n 
    return rest 
}

// type HTMLAttrs    = {[s:string]: string | Map<string, string>}
// type HTMLChildren<S> = string | number | boolean | S
// type Tag = [{_tag_: string} & HTMLAttrs, ...HTMLChildren<Tag>[]]

type HTMLLeaf = string | number | boolean
type HTMLBranch = ArrayBranch<{_tag_: string} & HTMLAttrs, HTMLLeaf> 

// isLeaf works
// value is { n[0]._tag_ }
// construct(b, branches) = [{_tag_: b}, branches] 
// attach(n, branches) works 
// branch(n) works 

// Laws: given n: Branch
// construct(value(n), branch(n)) == n 
// isLeaf(attach(n, [n1, n2,...])) == false 
// isLeaf(construct(b, [n1, n2, ...])) == false 
// branch(l extends L) == []  (branch of a leaf is empty array)
// attach(construct(value(n), []), branch(n)) == n ([] can be replaced by any iterable)

// typeclasses are not a thing in JS
// Nestable<B, L> {
//   branch(n:Nestable<B, L>): Nestable<B, L>[]
//   attach(value: B, branches: Nestable<B, L>[]):  Nestable<B, L>[]
//   attach(n:Nestable<B,L>, branches: Nestable<B,L>[]): Nestable<B,L>[]
//   isLeaf(n:L | Nestable<B,L>): n is L
// }


/**
Converts an array of tokens some of which delimit the start and end of a block
into a array of trees (also called a "forest").
This uses non-tail recursion so it is not memory safe, 
but it was easy to write and should be fine because I do not expect
people to create a 100 nested deep file. Maximum I can imagine 4-5 nests. 

The consumer of this function should prepend the list with something that 
represents a Head of a tree if they want to parse further with tree-walk 
functions. (basically making a forest back into a tree again, by assigning
them all a common parent). 

start and end should produce a value from the token when it is valid and 
should produce undefined when not.
*/
export function forestify<H, T>(start: (t:T) => H | undefined, end: (t:T) => any, tokens: T[], pos: number=0): [ArrayTree<H, T>[], number]
  forest : ArrayTree<H,T>[] .= [] 
  i .= pos
  while i < tokens.length
    token := tokens[i]
    s := start(token) 
    if s is not undefined 
      // an extra start will just consume input till the end of the file. 
      // It's not possible to know where the end got missed, only that it did.
      // This is a good way to gracefully degrade.
      [subtree, endi] .= forestify(start, end, tokens, i+1)
      // currently Forest<ArrayBranch<B, L>> = ArrayBranch<B, L>[] 
      forest.push(construct(s, subtree))
      i = endi 
    else if !!end(token)
      // an extra end will abort parsing early and cause the rest of the input to not be parsed.
      // again, it's a way to gracefully degrade.
      // the main `forestify` function will check for this case and append a string error message.
      return [forest, i+1]
    else 
      forest.push(token)
      i += 1
  [forest, i]

/** 
  performs a 1-level tree construction, leaving lower strings intact. 
  it's as if we noticed the first level of the tree and left everything else alone.
  forestify will detect subtrees which may not be what you want. 

  techincally this function takes a third argument for how to combine T[]. 
  right now i assume string and join on '\n'. 
*/
export function forestify1<H, T>(start: (t:T) => H | undefined, end: (t:T) => any, tokens: T[], pos: number=0): ArrayTree<H, T>[]
  forest : ArrayTree<H,T>[] .= [] 
  i .= pos
  level .= 0
  for token of tokens
    s := start(token)
    if s is not undefined 
      if level == 0 then forest.push([s])
      else (forest[forest.length-1] as ArrayBranch<H,T>).push(token)
      level += 1
    else if !!end(token) 
      //forest[forest.length-1] = [value(forest[forest.length-1] as ArrayBranch<H, T>), forest[forest.length-1].slice(1).join('\n')]
      level -= 1
    else 
      if level == 0 then forest.push(token) 
      else (forest[forest.length-1] as ArrayBranch<H,T>).push(token)
  
  return forest



function check(test: string | RegExp): (value: string) => { [key: string]: string; } | undefined
  function(value: string)
    if test <? RegExp
      value.match(test)?.groups
    else 
      return test is value ? {name: test} : undefined


export function forestify_(start: string | RegExp, end: string | RegExp, tokens: string[], pos?:number)
  [tree, endi] := forestify<{[s:string]: string}, string>(check(start), check(end), tokens)
  if endi >= tokens.length 
    return tree
  else 
    return [...tree, `Found an extra end token ${end} at position ${endi-1} in tokens: ${tokens}`]


/**
more generic versions of postwalk and prewalk would take 
the branch and attach/construct functions as arguments.
or they would exist in a type system where you could specialize 
functions on types instead of only classes.
the reason being that you may want to only explore parts of the tree
or have different rules for building new trees based on what node you are on. 
this simple version works for my case. 
*/
function postwalk<H, T>(f: (t: ArrayBranch<H, T>) => ArrayTree<H, T>, tree: T): T
function postwalk<H, T>(f: (t: ArrayBranch<H, T>) => ArrayTree<H, T>, tree: ArrayBranch<H,T>): ArrayBranch<H, T>
function postwalk<H, T>(f: (t: ArrayBranch<H, T>) => ArrayBranch<H, T>, tree: ArrayTree<H,T>): ArrayTree<H, T>
function postwalk<H, T>(f: (t: ArrayBranch<H, T>) => ArrayBranch<H, T>, tree: ArrayTree<H,T>): ArrayTree<H, T>
  // yield processed nodes in pre-walk order, transforming the *processed* child nodes, 
  // not the original node. Excludes leaf nodes (those require a ArrayTree => ArrayTree transformation)
  if isLeaf(tree) then return tree 
  branches := branch(tree).map((x) => postwalk(f, x))
  f(construct(value(tree), branches))

function prewalk<H, T>(f: (t: ArrayBranch<H, T>) => ArrayTree<H, T>, tree: T): T
function prewalk<H, T>(f: (t: ArrayBranch<H, T>) => ArrayTree<H, T>, tree: ArrayBranch<H,T>): ArrayBranch<H, T>
function prewalk<H, T>(f: (t: ArrayBranch<H, T>) => ArrayTree<H, T>, tree: ArrayTree<H,T>): ArrayTree<H, T>
function prewalk<H, T>(f: (t: ArrayBranch<H, T>) => ArrayTree<H, T>, tree: ArrayTree<H,T>): ArrayTree<H, T>
  if isLeaf(tree) return tree 
  n .= f(tree) 
  if isLeaf(n) return n
  b := branch(n) // returns undefined if the branch is not to be explored.
  if b
    return construct(value(n), b.map((t: ArrayTree<H, T>) => prewalk(f, t)))
  n

function prewalkL<B, L>(f: (t: L) => ArrayTree<B, L>, tree: L): ArrayTree<B, L>
function prewalkL<B, L>(f: (t: L) => ArrayTree<B, L>, tree: ArrayBranch<B,L>): ArrayBranch<B, L>
function prewalkL<B, L>(f: (t: L) => ArrayTree<B, L>, tree: ArrayTree<B,L>): ArrayTree<B, L>
function prewalkL<B, L>(f: (t: L) => ArrayTree<B, L>, tree: ArrayTree<B,L>): ArrayTree<B, L>
  /**
  transforms leaf nodes while also traversing any tree that is created, if relevant. 
  */
  if isLeaf(tree) 
    subtree := f(tree) 
    if isLeaf(subtree) return subtree 
    // also recursively traverse the newly generated subtree. 
    return prewalkL(f, subtree) 
  construct(value(tree), branch(tree).map((t: ArrayTree<B, L>) => prewalkL(f, t)))


function concat<H>(f: (h:H) => string, t: ArrayTree<H, string>): string
  if isLeaf(t) return t 
  return f(value(t)) + branch(t).map((st) => concat(f, st)).join('\n')

type Head = {[_:string]:string}
type AST = ArrayBranch<Head, string> 

export function splitblocks(text: string) 
  forestify_(/^----*(?<name>[a-z][a-z0-9-]*)\s*(?<args>\S.*)?$/, /^(?<dummy>\.\.\.\.*)\s*$/, text.split('\n'))

export function splitblocks1(text: string)
  forestify1(check(/^----*(?<name>[a-z][a-z0-9-]*)\s*(?<args>\S.*)?$/), check(/^(?<dummy>\.\.\.\.*)\s*$/), text.split(/\n+/))

type TagD = [string, HTMLAttrs]
type Tag2 = ArrayBranch<TagD, string>

// consider following example
// sidebyside is post block, katex is none and quote is a frame block.

function isTag2(x: any): x is Tag2
  o := x[0]
  o <? Array and R.type(o[0]) === 'String' and R.type(o[1]) === 'Object'

export function defrag(tree: Tag2) 
  return construct(value(tree), R.chain<Tag2 | string, string | Tag2>((x) => !isLeaf(x) and value(x)[0] === '<>' ? branch(x) : [x], branch(tree)))

// can receive a string, a parsed HTML tag or a pre-parsed block description (match groups) 
// pre-parsed tag needs to be parsed as a block
// post-parsed tag structure is arbitrary and not clear where it transitions to a block structure 
// in the POST nesting case (there can be text inside that represents a block) 
export function parse(registry: Registry, ast: AST | Tag2 | string, parent?: Block): Tag2
  // where does parseinline go? POST and SUB together make this complicated 
  if not isLeaf<Head | TagD, string>(ast) 
    // all attributes are ignored. when I add components, attributes need to be parsed for components as well. 
    if isTag2(ast)
      // Nesting.POST case 
      // we evaluate the strings underneath inside the context of the current block
      return defrag(construct(value(ast), branch(ast).map((node) => parse(registry, node, parent))))
    else if ast.length >= 2 and R.all((x) => R.type(x) === 'String', ast.slice(1))
      // Nesting.SUB parent case, we are being given a block name and a series of strings. There should not be anything else
      block := registry.resolve(value(ast).name)
      text: string := ast.slice(1).join('\n') as string
      opts: BlockOptions := R.omit(['name'], value(ast))
      // the tag name should be a block but just check
      if block !<? Block then throw Error(`Something strange happened: ${block} is not a Block. while parsing\n${ast}`)
      switch block.nest 
        when Nesting.NONE 
          return defrag(block.parse(text, opts ))
        when Nesting.POST 
          parsed := block.parse(text, opts)
          final := construct(value(parsed), branch(parsed).map((node) => parse(registry, node, block)))
          console.log(final)
          return defrag(final)
        when Nesting.SUB 
          lexed := splitblocks1(text) 
          subbed := lexed.map((node, i) => isLeaf(node) ? node : `[|${i}|]`).join('\n\n') //lexed.map((node) => isLeaf(node) ? parseinline(registry, block, node) : construct(value(node), branch(node).map((n) => continue))
          parsed := block.parse(subbed, opts)
          return defrag(Array.from(splicehtmlmap((node: string) => !!node.match(/\[\|\d+\|\]/) ? parse(registry, lexed[parseInt(node.slice(2, -2))]) : node, parsed)))
          // when Nesting.FRAME 
          //   // this case is equivalent to calling splitblocks inside the parser
          //   return block.parse(splitblocks(ast)) as unknown as Tag2
    else 
      throw Error(`Something strange happened\n${ast}\nisn't a recognized format for parsing.`)
      // return construct<TagD, string>(value(ast), branch(ast).map((node) => parse(registry, tag <? Block ? tag : block, node)))
  else 
    // isleaf (ast is a string) 
    // in the nesting.post case, this string can potentially contain a block. 
    // in all other cases, the string should just be parsed inline. 
    // regardless, there is no harm in attempting to detect a block and then dealing with the situation.
    if not realQ(parent) then throw Error(`Something strange happened, you're trying to parse a string without a parent block context. ${parent}\n${ast}`)
    if parent and parent.nest === Nesting.POST 
      // could have a sub block in the array, so two layers of fragments will be generated for each string.
      p1 := splitblocks1(ast)
      body := if p1.length > 1 then p1.map((x) => parse(registry, x, parent)) else parseinline(registry, parent, p1[0])
      return [['<>', {}], body...]
    // otherwise there should be no blocks in the string: 
    return [['<>', {}], ...parseinline(registry, parent, ast)]

